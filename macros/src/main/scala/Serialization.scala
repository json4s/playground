import language.experimental.macros
import scala.reflect.macros.Context

import org.json4s.{JsonWriter,JValue}

// Makes the code generated by the macros significantly less cumbersome
class WriterStack[T](var current:JsonWriter[T]) {
  def startArray() = {
    current = current.startArray()
    current
  }
  def endArray() = {
    current = current.endArray()
    current
  }
  def startObject() = {
    current = current.startObject()
    current
  }
  def endObject() = {
    current = current.endObject()
    current
  }
  def primative(value:Any) = { 
    current = value match {
      case a:Int        => current.int(a)
      case a:String     => current.string(a)
      case a:Float      => current.float(a)
      case a:Double     => current.double(a)
      case a:Boolean    => current.boolean(a)
      case a:Long       => current.long(a)
      case a:Byte       => current.byte(a)
      case a:BigInt     => current.bigInt(a)
      case a:Short      => current.short(a)
      case a:BigDecimal => current.bigDecimal(a)
    }
    current
  }
  def startField(name: String) = {
    current = current.startField(name)
    current
  }
  def addJValue(jv: JValue) = {
    current = current.addJValue(jv)
    current
  }
  def result = current.result
}

// Intended to be the serialization side of the class builder
object Serialization {
  type Writer = JsonWriter[_]
  
  def serObj[U](obj:U, name:String, writer: Writer) = macro impl[U]
  def impl[U:c.WeakTypeTag](c: Context)(obj: c.Expr[U], name: c.Expr[String], writer: c.Expr[Writer]):c.Expr[Unit] = {
                      
    import c.universe._
    val helpers = new MacroHelpers[c.type](c)
    import helpers._
    
    // Will help manage the JsonWriters for us instead of having to
    // keep track as we go down the tree
    val Block(writerStackDef::Nil,_) = reify{
      val writerStack = new WriterStack(writer.splice)
    }.tree
    val writerStack = c.Expr[WriterStack[_]](Ident("writerStack"))
    
    val primativeTypes = typeOf[Int]::typeOf[String]::
                          typeOf[Float]::typeOf[Double]::
                          typeOf[Boolean]::typeOf[Long]::
                          typeOf[Byte]::typeOf[BigInt]::
                          typeOf[Short]::typeOf[BigDecimal]::Nil
    
    
    // Assumes that you are already in an object or list
    def dumpObject(tpe:Type,path:Tree,name:c.Expr[String],isList:Boolean=false):c.Tree = {
      
      val startFieldExpr = if(isList) {
        reify{}
      } else reify{writerStack.splice.startField(name.splice)}
      
      if(primativeTypes.exists(_ =:= tpe)) { // Must be primative
        reify{
          startFieldExpr.splice
          writerStack.splice.primative(c.Expr(path).splice)
        }.tree
      } 
      // Handle the lists
      else if(tpe <:< typeOf[scala.collection.Seq[Any]]) {
        val TypeRef(_,sym:Symbol,pTpe::Nil) = tpe
        reify{
          startFieldExpr.splice
          writerStack.splice.startArray()
          c.Expr[scala.collection.Seq[Any]](path).splice.foreach { i =>
            c.Expr(dumpObject(pTpe,Ident("i"),LIT(""),isList=true)).splice
          }
          writerStack.splice.endArray()
        }.tree
      } 
      
      else if(tpe <:< typeOf[scala.collection.GenMap[Any,Any]].erasure) {
        val TypeRef(_,_,keyTpe::valTpe::Nil) = tpe
        
        if(!primativeTypes.exists(_ =:= keyTpe)) {
          c.abort(c.enclosingPosition,
            s"Maps nees to have keys of primative type! Type: $keyTpe")
        }
        val kExpr = c.Expr[String](Ident("kstr"))
        reify{
          startFieldExpr.splice
          writerStack.splice.startObject()
          c.Expr[scala.collection.GenMap[Any,Any]](path).splice.foreach { case (k,v) =>
            val kstr = k.toString
            c.Expr(dumpObject(valTpe,Ident("v"),kExpr)).splice
          }
          writerStack.splice.endObject()
          
        }.tree
        
      // Handle Options
      } else if(tpe <:< typeOf[Option[Any]]) {
        val TypeRef(_,sym:Symbol,pTpe::Nil) = tpe
        reify{
          c.Expr(path).splice match {
            case Some(x) => c.Expr[Unit](dumpObject(pTpe,Ident("x"),name)).splice
            case None    => Unit
          }
        }.tree
      } 
      
      else {  // Complex object
        val TypeRef(_,sym:Symbol,tpeArgs:List[Type]) = tpe
        // get fields
        val fields = getVars(tpe):::getVals(tpe)
        val fieldTrees = fields map { pSym => 
          val pTpe = pSym.typeSignature.substituteTypes(sym.asClass.typeParams,tpeArgs)
          val fieldName = pSym.name.decoded.trim    // Do I need to trim here?
          val fieldPath = Select(path,newTermName(fieldName))
          dumpObject(pTpe,fieldPath,LIT(fieldName))
        }
        
        // Return add all the blocks for each field and pop this obj off the stack
        Block(
        reify{
          startFieldExpr.splice
          writerStack.splice.startObject()
        }.tree::fieldTrees
        ,reify{writerStack.splice.endObject()}.tree)
      }
    } // dumpObject
    
    val code = Block(
      writerStackDef::
      reify{
        writerStack.splice.startObject()
      }.tree::
      dumpObject(weakTypeOf[U],obj.tree,name)::
      reify{
        writerStack.splice.endObject()
      }.tree::Nil,
      c.literalUnit.tree
    )
    //println(s"------------------ Debug: Generated Code ------------------\n $code")
    c.Expr[Unit](code)
  }
  
}
